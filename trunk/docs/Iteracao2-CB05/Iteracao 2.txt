<==== Objectivos ==============================================================>
Determinar o modelo de dados e as funcionalidades base para a gestão e 
organização da informação.
Criar regras para a internacionalização da aplicação.
Criar a estrutura da base de dados a usar e configurar um motor de bases de 
dados para usar durante o processo de desenvolvimento.
Desenvolver a interface com utilizador para garantir o acesso às 
funcionalidades indicadas, tendo por base a interface gráfica dos sistemas 
analisados.

Será também incorporado o código da iteração anterior.
<==== Documentos produzidos ===================================================>
Modelo de dados:
	Diagrama de Classes - Projecto Netbeans com o modelo de dados.
	entities diagram.png - Imagem obtida pela exportação do diagrama do modelo 
		de dados
	
Spikes:
	Prototipo - Protótipo de aplicação
Outros documentos:
	i18n.txt - Identificação do sistema usado para a internacionalização e das 
		regras a seguir.
	TestingDB - Pasta com uma base de dados usada nos testes.

<==== 
Etiquetas e categorias não possuem diferenças práticas, catalogar por categorias 
ou por etiquetas é a mesma situação, podemos considerar que categorias são um 
caso especial de etiquetas. Nesse sentido será eliminada a organização por 
categorias ficando apenas a organização por etiquetas.

Um disco, elemento que pode ter associado vários ficheiros, corresponde a uma 
drive ligada ao PC ou numa localização na rede e pode conter ficheiros cujas 
descrições serão importadas.
Os discos podem ser agrupados em grupos de discos. Grupos de discos podem 
conter outros grupos de discos.
Existe também a possibilidade de catalogar pastas contindas em discos rígidos.
Neste caso, estas pastas terão exactamente as mesmas características que um 
disco pelo que podemos acrescentar que um disco pode ser, além de um suporte 
físico, uma pasta contida num qualquer suporte físico.

Uma etiqueta é apenas um nome que representa uma forma de organizar determinado 
disco ou grupo de discos.

Um catálogo, ao ser apresentado, possuí como elemento raíz, um nó com o nome do 
catálogo. Este é o elemento raíz no qual todos os restantes elementos, sejam 
outros grupos ou apenas discos, podem ser colocados.
De um grupo de discos é necessário reter o nome, o número de discos associados, 
a capacidade total oferecida pelos discos associados, o espaço livre total que 
existe nos discos associados, o número total de pastas e de ficheiros, a lista 
de etiquetas atribuídas a este grupo de discos e uma descrição para o grupo.
De uma etiqueta importa guardar o nome.
Os discos contêm a informação do nome atribuído ao volume pelo SO, o número 
automático atribuído pelo programa, o tipo de suporte, se é DVD-ROM, CD-ROM, HDD, 
etc., o número de série, um nome definido pelo utilizador, a localização física 
do disco, as etiquetas a que pertence, o espaço livre e o espaço ocupado e uma 
descrição.

Os catálogos são guardados usando bases de dados relacionais, o nome do 
catálogo é usado para o nome da base de dados.
Será vantajoso usar uma tecnologia ORM para diminuir a distância entre os 
objectos usados e a estrutura da base de dados bem como remover da equipa de 
programadores as preocupações que o mapeamento entre objectos e tabelas 
correspondentes impõe.
Na criação de um novo catálogo será necessário pedir o nome a dar ao catálogo, 
sendo que os dados de ligação à base de dados devem já estar preenchidos com 
dados que tenham sido configurados anteriormente num painel de opções. No 
entanto deverá ser possível alterar os mesmos dados.
Para efectuar uma ligação à base de dados é necessário indicar o URL para a 
ligação, o nome de utilizador e palavra-passe de acesso e o tipo de motor de 
bases de dados a usar.

Os casos de uso a desenvolver deverão ser baseados no protótico criado 
anteriormente e na aplicação já existente, Where Is It.
O uso de casos de uso prende-se com o que estes podem oferecer como guias no 
desenvolvimento, não serão consideradas descrições elaboradas dos casos de uso 
e apenas serão valorizados os diagramas para que seja mais fácil manter um 
registo das tarefas a executar.

Será necessário desenhar interfaces que permitam gerir catálogos - criar, 
abrir, manter registo de catálogos recentes, fechar e guardar catálogos.
É necessário criar os seguintes elementes de interação com o utilizador:
- Janelas de Diálogo:
	- NewDiskDlg - Janela de diálogo que permite ler novos suportes.
	- NewCatalogDlg - Janela de diálogo que permite criar novos catálogos
	- OpenCatalogDlg - Janela de diálogo que permite abrir catálogos 
		existentes.
	- CatalogPropertiesDlg - Janela de diálogo que permite ver as 
		propriedades do catálogo e editar a data de criação e a 
		descrição.
- Menus:
- Paineis a integrar no sistema de janelas da plataforma:
	- CatalogOptionsPanel - Painel com as apções a usar na criação de novos 
		catálogos e abertura de catálogos existentes.
	- NavigationTreeTopComponent - Componente que permite navegar nos 
		elementos que compoem um catálogo. Mostra os dados existentes 
		num catálogo na forma de uma árvore.
<==== Avaliação ===============================================================>
Esta iteração passou o tempo previsto por duas semanas. Foram encontradas 
várias dificuldades na correcta implementação dos métodos e objectos, para que 
fosse possível à componete visual ter acesso aos dados a mostrar.
Incorporar um sistema de persistência, como o Hibernate, na plataforma netbeans 
provou também ser um desafio maior que esperado. Não foram encontrados 
tutoriais ou outra documentação sobre o assunto, e consultada a lista de 
discussão descobriu-se que muito poucos programadores tinha implementado ou 
estavam a implementar uma solução de software que envolvesse a integração de um 
sistema de persistência que usasse, como apoio, um motor de bases de dados 
relacionais, ou  mesmo que usasse um sistema ORM para efectuar o mapeamento 
entre os objectos e as tabelas da base de dados.

Como principais problemas, no que toca à integração do mecanismo 
de persistência na plataforma, surgiram: a dificuldade inicial de criar as 
dependências correctas para que os diferentes módulos pudessem comunidar, as 
combinações das bibliotecas necessárias provocaram alguns conflitos; a 
dificuldade de garantir a correcta configuração da camada ORM através do uso de 
ficheiros XML e de configuração programática; a dificuldade em determinar um 
nível de isolamento que permitisse ao Hibernate trabalhar correctamente. Dado 
que não estamos a criar uma aplicação empresarial que use um qualquer servidor 
aplicacional não pudemos usar o sistema de transições do Java, Java Transition 
API (JTA), não tendo assim o controlo de transições e o nível de isolamento 
oferecido por esse tipo de servidores. Para desenvolvimento futuro deverá ser 
considerada a possibilidade de, embora não usando um servidor aplicacional, 
conseguir usar o sistema de transacções do Java, JTA, bem como remover a 
dependência do sistema ORM escolhido, através do uso de Java Persistence API.

A configuração dos ficheiros de mapeamento de objectos do Hibernate provocaram 
vários atrasos. O mapeamento inicial não estava implementado correctamente, mas 
os problemas só foram detectados quando, após vários dias de utilização 
aparentemente normal, se efectuaram algumas alterações nas estruturas das 
entidades de persistência e que revelaram as falhas no mapeamento.
Todos os relacionamentos, cardinalidades e navegabilidades entre as entidade 
tiveram de ser reescritos e todos os mapeamentos criados anteriormente foram 
alterados.

Na componente visual, criar e mostrar nós que representem os dados, foi também 
um processo que levou mais tempo que esperado, tendo sido um dos pontos que 
mais pesou no atraso da iteração.
Uma vez que os dados são obtidos através de uma ligação à base de dados, é 
necessário ter atenção ao tempo que levam a ser contruído, sendo necessário 
fazer a sua construção de forma assíncrona e num processo que não interfira a 
interação com o utilizador.
A API da plataforma, no que toca a nós, está bastante virada para o uso de nós 
que representem ficheiros, ou vistas de ficheiros como é o caso dos ficheiros 
JAR que contém no seu interior outros ficheiros.
Colocar essa API a representar dados que não estão presentes em disco ou e que 
além de demorarem a ser obtidos, não podem ser facilmente manipulados como 
qualquer outro ficheiro levou a que muito código, que de outra forma seria 
criado automaticamente, tivesse de ser criado manualmente. Muito desse código 
não era comum nos tutoriais e na documentação consultada e algumas tarefas não 
foram atingidas com sucesso.

No que toca a funcionalidades, a iteração não obteve o sucesso desejado, 
ficando por implementar o código que permita ver o conteúdo dos nós 
seleccionados e que possibilite que alterações à base de dados sejam mostradas 
ao utilizador em tempo real.